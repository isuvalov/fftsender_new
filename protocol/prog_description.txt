В функции srv_prepare_resp() происходит проверка какой запрос пришел и подготавливается соответствующий ответ:
RRW_FN_STATUS=0x00:  srv_prepare_status_resp(srv);
RRW_FN_MEAS_CTL=0x02: srv_prepare_meas_ctl_resp(srv);
RRW_FN_DATA_ALT=0x01: srv_prepare_data_alt_resp(srv);
RRW_FN_GET_TH=0x04,RRW_FN_SET_TH=0x03:  srv_prepare_getth_resp(srv);




В файле eudp.cpp имеется Define RTL_SIMULATION
 
-------------

Итак.
Файл UdpRadar.cpp
 
Основная функция чтения данных:
строка 108: read_sweeps().
В ней вызывается функция аккумуляции пакетов строка 79: collect_packets() . Она аккумулирует пакеты в векторе sweeps [ i ] [ j ], где i - номер свипа, j - номер пакета (0 <= j < 4).
Логику парсинга номеров свипа и пакета смотри в строках 92-96.
 
Сейчас, в режиме RTL_SIMULATION, эта функция аккумуляции не используется.
 
При успешном накоплении всех 4 пакетов выполняется дешифрация данных.
Со строка 118 начинается цикл по накопленным пакетам свипов. Смотри комментарии в коде.
Сейчас этот блок парсинга шунтирован циклом прямой записи в двумерный вектор data значений счетчика (как мы договаривались, вопрос подбора нужного множителя может быть актуальным - сейчас я поставил 10: строка 136).
 
Здесь все! Если данные успешно получены, то переходим
Файл UdpServer.cpp
строка 245: начало функции create_data().
В ней в строке 273 вызывается функция расчета целей,
а в цикле, начиная со строки 279, происходит сохранение данных для каждой из 1024 отсчетов, в том числе там и перевод в Дбм.


---
UdpRadar.cpp  - получение данных из пакетов
SweepRadar.cpp - нахождение максимумов
Processor.cpp  - обработка максимумов

Функция bool SweepRadar::calculate() в SweepRadar.cpp проходит полный массив и делает по нему search_maximums